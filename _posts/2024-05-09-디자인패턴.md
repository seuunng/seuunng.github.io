---
layout: post
title: 소프트웨어 설계 문제에 대한 해결책하는 디자인 패턴
author: 개발자씅
categories: 
- 코딩
tags: 깃 깃허브 포트폴리오 깃허브포트폴리오 개발자포트폴리오 노션 개발자포트폴리오양식 개발자포트폴리오예시 국민취업지원제도 개발자채용 디자인패턴 생성패턴 구조패턴 행동패턴 싱글톤 팩토리메서드 추상메서드 빌더 프로토타입 
keywords: 깃 깃허브 포트폴리오 깃허브포트폴리오 개발자포트폴리오 노션 개발자포트폴리오양식 개발자포트폴리오예시 국민취업지원제도 개발자채용 디자인패턴 생성패턴 구조패턴 행동패턴 싱글톤 팩토리메서드 추상메서드 빌더 프로토타입 
date: 2024-05-09 10:00 +0800
lastmode: 2024-05-09 10:00 +0800
published: true
toc: true
excerpt: 싱클톤 패턴말고 다른 디자인 패턴도 있을까?
description: 디자인패턴의 종류와 사용예시, 구현방법
---

## 디자인 패턴

디자인 패턴은 소프트웨어 설계에서 반복적으로 발생하는 문제들을 효과적으로 해결하기 위해 일반화된 재사용 가능한 패턴을 말한다. 이러한 패턴들은 대개 특정 문제를 해결하는 구조와 방식을 설명하고, 이를 통해 코드의 유지보수성, 확장성 및 재사용성을 향상시키는 데 도움을 준다. 디자인 패턴은 크게 세 가지 주요 카테고리로 분류된다.

### 생성패턴(Creational Patterns)
> 생성 패턴은 **객체 생성**에 관련된 패턴으로, 객체의 생성과 클래스화를 **캡슐화**하는 방법을 제공한다. 이는 시스템의 독립성과 유연성을 높인다.

1. **Singleton(싱글톤)**: 싱글톤 패턴은 어떤 클래스의 인스턴스가 **프로그램 전체에서 하나만 존재**해야 할 때 사용한다. 이 패턴은 전역 변수를 사용하지 않고 객체에 **전역 접근을 제공**하고자 할 때 유용하다.

    사용예시
    1) **설정관리자**
    2) 파일 시스템의 접근 로그

    주요 구성 요소
    1) Instance: 유일한 인스턴스를 유지
    2) Constructor: private으로 선언하여 외부에서의 인스턴스 생성을 막는다.
    3) getInstance 메서드: 외부에서 유일한 인스턴스에 접근할 수 있는 메서드를 제공

    동작 과정
    1) getInstance 메서드를 호출하여 인스턴스를 얻는다.
    2) 인스턴스가 없을 경우 생성하고, 있을 경우 기존 인스턴스를 반환한다.

    장점
    1) 전역 상태를 유지하므로 객체 간의 결합도를 줄인다.
    2) 인스턴스가 하나만 생성되므로 메모리를 절약할 수 있다.

    사용예시
    1) 시스템 전체에 걸쳐 하나의 인스턴스만 있어야 할 때
    2) 공유 자원에 대한 일관된 접근점이 필요할 때
    3) 복잡한 객체를 여러번 생성하는 것이 리소스 낭비일 때

    구현 방법 및 예제
    1) 생성자를 private으로 선언
    2) 클래스 내부에 static 변수를 선언하여 클래스의 유일한 인스턴스를 저장
    * static: 클래스의 모든 인스턴스가 공유하는 변수
```
public class Singleton {
    // private static 변수로 인스턴스를 하나만 유지한다.
    private static Singleton instance;

    // 생성자를 private으로 선언하여 외부에서 인스턴스를 생성하지 못하도록 막는다.
    private Singleton() {
    }

    // getInstance 메서드를 통해 인스턴스를 얻을 수 있다.
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
멀티스레드 환경을 고려한 보다 안전한 Singleton 패턴을 만들기 위해 synchronized 키워드를 사용하기도 한다. synchronized는 스레드 안전을 보장하지만 성능 저하를 초래할 수 있다. 이러한 단점을 해결하기 위한 또 다른 방법으로 Double-Checked Locking 패턴을 사용할 수 있다.

2. **Factory Method(팩토리 메서드)**: 생성할 객체의 클래스를 직접 지정하지 않고, 객체를 생성할 때 **인터페이스를 통해 객체의 인스턴스를 생성하는 방법**을 정의한다. 이런 Factory Method 패턴은 객체의 생성 과정에 대한 유연성과 확장성이 필요할 때 사용된다.

    사용예시
    1) **GUI 요소** 생성
    2) **데이터베이스 연결 객체** 생성
    
    주요 구성 요소
    1) Creator: 팩토리 메서드를 선언하는 클래스
    2) ConcreteCreator: 실제 객체를 생성하는 클래스
    3) Product: 생성되는 객체의 인터페이스를 정의
    4) ConcreteProduct: 실제 생성되는 객체를 구현

    동작 과정
    1) Creator 클래스에서 팩토리 메서드를 선언
    2) ConcreteCreator 클래스에서 해당 메서드를 구현하여 객체를 생성
    3) 클라이언트는 Creator를 통해 객체를 생성

    장점
    1) 객체 생성 로직을 캡슐화하여 중복을 줄인다
    2) 클라이언트와 구체적인 생성 로직을 분리한다.

    사용 시기
    1) 생성할 객체의 **정확한 타입을 런타임에서 결정**해야 할 때: 클라이언트 코드가 생성할 객체의 클래스를 몰라도 될 때 이 패턴을 사용하여 객체 생성을 서브클래스에 위임한다.
    2) 객체 생성 로직의 **중복을 줄이고**자 할 때: 여러 클래스에서 비슷한 방식으로 객체를 생성하는 경우, 팩토리 메서드를 사용하여 중복을 제거하고 유지 보수를 용이하게 할 수 있다.
    3) **클라이언트 코드와 생성되는 인스턴스를 분리**할 필요가 있을 때: 클라이언트 코드가 특정 인스턴스가 아닌 인터페이스나 기본 클래스와 작업해야 할 때 유용하다.

```
// Product 인터페이스: 공통 인터페이스 정의
interface Product {
    void use();
}

// ConcreteProduct 클래스들
class ConcreteProductA implements Product {
    public void use() {
        System.out.println("Using ConcreteProductA");
    }
}
class ConcreteProductB implements Product {
    public void use() {
        System.out.println("Using ConcreteProductB");
    }
}

// Creator 클래스: Product 인스턴스를 생성
abstract class Creator {
    public abstract Product createProduct();

    public void anOperation() {
        Product product = createProduct();
        System.out.println("An operation with " + product.getClass().getSimpleName());
        product.use();
    }
}

```


3. **Abstract Factory(추상 팩토리)**: 서로 관련있는 **여러 종류의 객체를 일관된 방식으로 생성**할 수 있는 인터페이스를 제공한다. 여러 공장을 위한 인터페이스를 제공하여, 클라이언트가 구체적인 클래스를 명시하지 않고도 서로 연관되거나 의존적인 객체들의 그룹을 생성할 수 있게 해주는 생성 디자인 패턴이다.

    예시
    1) **GUI 테마**를 변경할 때 사용되는 버튼, 창 등의 객체 생성, 다크모드, 라이트 모드

    주요 구성 요소
    1) AbstractFactory: 관련된 객체의 집합을 생성하기 위한 인터페이스를 정의  
    2) ConcreteFactory: 실제 객체를 생성하는 클래스  
    3) AbstractProduct: 생성되는 객체의 인터페이스를 정의  
    4) ConcreteProduct: 실제 생성되는 객체를 구현  

    동작 과정  
    1) AbstractFactory 인터페이스를 구현하는 ConcreteFactory 클래스를 생성한다  
    2) ConcreteFactory 클래스는 AbstractProduct를 구현한 ConcreteProduct 객체를 생성한다  

    장점  
    1) 관련된 객체 집합을 일관성 있게 생성할 수 있다.
    2) 객체의 생성 로직을 캡슐화하여 유연성을 높인다.

    사용 시기
    1) 여러 개의 연관된 객체 집합을 생성해야 할 때
    2) 생성된 객체들이 함께 사용되는 경우

4. **Builder(빌더)**: 복잡한 객체의 생성 과정과 그 표현 방법을 분리하여, **동일한 생성 과정에서 다른 표현 결과를 얻게하는** 생성디자인 패턴이다. 객체의 구성이 복잡하거나, 객체의 구성 과정이 특정 생성 순서에 의존할 때 유용하다.

    예시
    1) **HTML 문서**를 생성하는 빌더 패턴

    주요 구성 요소
    1) Builder: 객체 생성 과정을 정의하는 인터페이스를 제공
    2) ConcreteBuilder: Builder를 구현하여 객체를 생성하는 클래스
    3) Director: Builder를 사용하여 객체를 생성하는 클래스
    4) Product: 생성될 객체를 표현

    동작 과정
    1) Director 클래스는 ConcreteBuilder를 사용하여 객체 생성 과정을 제어합니다.
    2) ConcreteBuilder 클래스는 생성할 객체의 특정 부분을 구성합니다.

    장점
    1) 복잡한 객체의 생성 과정을 단순화하고 캡슐화
    2) 객체 생성 과정의 일부를 변경하거나 확장 용이

    사용시기
    1) 복잡한 객체를 단계별로 생성해야 할 때
    2) 생성과 표현의 분리가 필요할 때: 같은 생성과정에서 다양한 표현 결과를 만들어야 할때

5. **Prototype(프로토타입)**: 기존 객체를 **복제**함으로써 객체를 생성한다. Java에서 Cloneable 인터페이스와 clone() 메소드를 사용하여 구현 할 수 있다.

    예시
    1) 게임에서 **캐릭터를 복제**하여 새로운 캐릭터를 생성하는 경우

    주요 구성 요소
    1) Prototype: 객체를 복제하는 인터페이스를 정의
    2) ConcretePrototype: 실제로 복제될 객체를 구현

    동작 과정
    1) 원본 객체를 복제할 Prototype 인터페이스를 구현한 ConcretePrototype 클래스를 생성
    2) 클라이언트는 복제할 객체를 지정하여 Prototype의 clone 메서드를 호출

    장점
    1) 객체를 생성하는 복잡한 과정을 축소
    2) 런타임에 새로운 객체 생성 가능

    사용 시기
    1) 복잡한 객체의 생성 과정을 단순화해야 할 때
    2) 객체 생성이 런타임에 결정되어야 할 때

### 구조패턴(Structural Patterns)
> 구조 패턴은 클래스나 객체를 **조합**해 더 큰 구조를 만드는 방법에 관한 패턴이다. 이는 주로 클래스 **상속**을 통해 **인터페이스를 합성**하거나 **새로운 기능**을 구성한다.

1. **Adapter(어댑터_변환)**: **서로 호환되지 않는 인터페이스**를 가진 클래스들이 함께 작동할 수 있도록 하는 구조적 디자인 패턴이다. 

    예시  
    1) 여러 라이브러리나 프레임워크 간의 **호환성** 유지  
    2) 외부 API와의 통신을 위한 Wrapper 클래스  

    주요 구성 요소
    1) Target: 클라이언트가 사용하는 인터페이스  
    2) Adaptee: 실제 동작하는 클래스  
    3) Adapter: Target과 Adaptee 간의 인터페이스를 맞춰주는 클래스  

    동작 과정  
    1) 클라이언트가 Target 인터페이스를 통해 요청  
    2) Adapter는 이 요청을 Adaptee에 전달하고 결과를 반환  

    장점  
    1) 기존 코드를 수정하지 않고도 다른 인터페이스를 사용할 수 있다.  
    2) 호환되지 않는 인터페이스를 연결하여 유연성을 높인다.  

    사용 시기
    1) 기존의 클래스를 사용하고 싶지만, 인터페이스가 요구사항과 맞지 않을 때  
    2) 서로 관련 없는 클래스들을 함께 작동시켜야 할 때: Adapter를 사용하여 호환성 문제를 해결할 수 있다.  
    3) 기존 코드를 수정하지 않고도 기능을 확장하고 싶을 때: 외부 라이브러리 같은 변경할 수 없는 코드에 대해 새로운 인터페이스를 제공하고 싶을 때 유용하다.     

2. **Composite(컴포지트_합성)**:  클라이언트가 **개별 객체와 구성 객체의 그룹을 동일하게 처리**할 수 있도록 하는 구조적 디자인 패턴이다. 이 패턴은 객체의 **트리 구조**를 생성하여, 개별 객체와 복합 객체를 동일한 인터페이스를 통해 처리할 수 있게 한다. 이 패턴은 일반적으로 트리 구조로 표현되는 계층적인 컬렉션을 다룰 때 유용하다.

    예시  
    1) 파일 시스템의 **디렉토리**와 파일을 표현하는 클래스
    2) GUI에서 컴포넌트와 컨테이너를 다루는 클래스

    주요 구성 요소
    1) Component: 개별 객체와 복합 객체를 동일하게 다루는 인터페이스입니다.
    2) Leaf: 개별 객체입니다.
    3) Composite: 복합 객체로, Leaf나 다른 Composite 객체를 포함할 수 있습니다.

    동작 과정
    1) 클라이언트는 Component 인터페이스를 통해 Leaf와 Composite 객체를 다룹니다.
    2) Leaf 객체는 동작을 수행하고, Composite 객체는 자식 객체에게 동작을 위임합니다.

    장점
    1) 개별 객체와 복합 객체를 일관된 방식으로 다룰 수 있습니다. 
    2) 계층적인 구조를 통해 복잡한 객체를 관리할 수 있습니다. 

    사용시기
    1) 계층적 데이터 구조를 다룰 때: 파일 시스템, GUI, 조직도 등 계층적 구조를 가진 데이터를 표현하고 관리할 때 유용하다.
    2) 개별 객체와 객체의 그룹을 동일하게 다루고 싶을 때: 클라이언트가 개별 객체와 그룹을 구분하지 않고 일관된 방식으로 처리할 수 있게 하고 싶을 때 사용된다.
    3) 부분-전체 계층 구조를 만들고 싶을 때: 부분과 전체를 나타내는 객체를 같은 인터페이스로 관리하고 싶을 때 적합하다.

3. **Proxy(프록시_대리자)**: 객체에 대한 접근을 제어하거나 기능을 추가하기 위해 **대리자 또는 자리표시자**를 제공하는 구조적 디자인 패턴이다. 이 패턴은 다른 객체의 인터페이스로 기능하는 대리 객체를 생성하여 실제 객체에 대한 요청을 그 객체로 전달한다. **실제 객체와 동일한 인터페이스를 구현**하므로, 클라이언트는 실제 객체인지 프록시 객체인지 구분할 필요 없이 사용할 수 있다. 프록시는 실제 객체를 감싸는 래퍼(wrapper) 역할을 하여, 실제 객체에 직접 접근하는 것을 제어하거나, 추가적인 기능을 수행하도록 확장할 수 있다.
    예시
    1) **원격 서버에 접근**하는 웹 프록시 서버
    2) **데이터베이스 접근을 제어**하는 프록시 객체
    
    주요 구성 요소
    1) Subject: 실제 객체와 프록시 객체가 구현하는 인터페이스
    2) RealSubject: 실제 동작하는 클래스
    3) Proxy: RealSubject에 대한 접근을 제어하고 추가적인 기능을 제공하는 클래스

    동작 과정
    1) 클라이언트는 Subject 인터페이스를 통해 Proxy 객체에 접근한다.
    2) Proxy는 필요에 따라 RealSubject에게 요청을 전달하고 결과를 반환한다.

    장점
    1) 접근 제어 및 보안을 제공
    2) 원격 객체에 대한 로컬 인터페이스를 제공

    사용 시기
    1) 접근 제어
    2) 지연 초기화
    3) 로그 및 감사
    4) 복잡한 로직 숨기기
    5) 원격 객체 접근



4. **Facade(파사드_외관)**: **하나의 단순화된 인터페이스**를 통해 하나 이상의 복잡한 서브시스템의 인터페이스를 통합하는 구조적 디자인 패턴이다. 이 패턴의 목적은 복잡한 시스템을 더 쉽게 사용할 수 있도록 하는 것으로, 클라이언트가 시스템의 복잡한 부분과 직접적으로 상호작용할 필요 없이, Facade를 통해 간접적으로 접근하게 한다.

    예시
    1) 컴퓨터 **부팅** 과정을 단순화한 부팅 매니저
    2) 웹 서비스를 호출하는 API의 Wrapper 클래스

    주요 구성 요소
    1) Facade: 복잡한 서브시스템의 간략화된 인터페이스를 제공하는 클래스  
    2) Subsystem: 서브시스템을 구성하는 여러 클래스  

    동작 과정
    1) 클라이언트는 Facade 인터페이스를 통해 서브시스템에 접근
    2) Facade는 서브시스템의 복잡한 동작을 감추고 단순화된 인터페이스를 제공  

    장점
    1) 복잡한 서브시스템을 간략화하여 사용자가 쉽게 이해하고 사용할 수 있도록 한다.
    2) 클라이언트와 서브시스템 간의 의존성을 줄인다.

    사용 시기
    1) 복잡한 시스템을 간단하게 표현할 필요가 있을 때: Facade를 사용하여 사용자 친화적인 인터페이스를 제공할 수 있다.
    2) 시스템을 계층으로 나누고 싶을 때: Facade는 각 계층간의 상호작용을 단순화하는 데 도움을 줄 수 있다.
    3) 의존성을 줄이고 시스템의 결합도를 낮추고 싶을 때: 클라이언트가 시스템의 특정 부분만을 이용해야 할 경우, Facade는 이러한 구성 요소들 사이의 결합도를 낮추는 역할을 한다.

5. **Bridge(브릿지)**: 소프트웨어 디자인에서 **추상화와 구현을 분리**하여 유연성을 확보하는 데 사용된다. 이 패턴은 **두 개의 독립적인 계층을 서로 결합**할 때 유용하다. 여기서 "계층"은 추상화 계층과 구현 계층을 의미한다. 브릿지 패턴은 두 개의 다른 계층이 서로 독립적으로 변할 수 있도록 하여 변화에 유연하게 대처할 수 있게 한다.
    예시
    1) **다양한 종류의 도형**을 그리는 그림판 프로그램
    2) 다양한 운송 수단과 도로를 연결하는 교통 시스템

    주요 구성 요소
    1) Abstraction: 구현체(Implementor)에 대한 추상화된 인터페이스를 제공  
    2) RefinedAbstraction: Abstraction을 확장하여 추가적인 기능을 제공  
    3) Implementor: Abstraction의 구현체  
    4) ConcreteImplementor: Implementor를 실제로 구현하는 클래스  

    동작 과정
    1) Abstraction은 Implementor 인터페이스를 사용하여 기능을 수행한다.
    2) 실제 기능은 Implementor를 통해 구현된다.

    장점
    1) 추상화와 구현을 분리하여 유연성을 확보한다.
    2) Abstraction과 Implementor를 독립적으로 확장할 수 있다.

    사용 시기
    1) 추상화와 구현이 각각 독립적으로 변할 수 있는 경우
    2) 여러 개의 변화 요소가 존재할 때



### 행동 패턴(Behavioral Patterns)
> 행동 패턴은 객체나 클래스 사이의 **알고리즘**과 **책임 분배**에 관한 패턴이다. 이 패턴은 객체가 서로 어떻게 **통신**하는지, 어떻게 **협력**하는지에 중점을 둔다.

1. **Observer(관찰자)**: 이 패턴은 **객체의 상태 변화**가 다른 객체들에게 통지되어 자동으로 업데이트가 이루어지도록 하는 디자인 패턴이다. 

    예시
    1) 주식 시장에서 **주식 가격 변동을 감시**하는 시스템
    2) 온라인 뉴스 서비스에서 구독자에게 **새로운 기사를 알리는 기능**

    주요 구성 요소  
    1) Subject: 상태를 관찰하고 알림을 전송하는 주체
    2) Observer: Subject의 상태를 관찰하고 필요한 동작을 수행하는 객체

    동작 과정
    1) Subject의 상태가 변경된다.
    2) Subject는 등록된 Observer에게 상태 변경을 알린다.
    3) Observer는 상태 변경에 따라 필요한 동작을 수행한다.

    장점
    1) 느슨한 결합을 제공하여 유연성을 높인다.
    2) 상태 변경에 대한 알림을 효율적으로 처리한다.

    사용시기
    1) 객체간의 일대다 의존성이 존재하고 이러한 의존성을 느슨하게 유지하고 싶을 때 
    2) 객체의 상태 변화에 따라 다른 객체들에게 자동으로 알림을 주고 싶을 때


2. **Strategy(전략)**: **알고리즘**을 정의하고 각각을 캡슐화하여 서로 교체 가능하게 만든다. 이는 실행 중에 알고리즘을 선택할 수 있게 해주고, **동일한 문제를 해결하기 위한 여러 전략들을 유연하게 적용**할 수 있도록 한다.
    사용예시
    1) **정렬** 알고리즘: 필요에 따라 퀵 정렬, 병합 정렬, 버블 정렬 등의 전략 중 하나를 선택하여 사용할 수 있다.
    
    주요 구성 요소
    1) 전략(Strategy): 알고리즘을 나타내는 인터페이스 또는 추상 클래스
    2) 구체적인 전략(Concrete Strategy): 전략을 실제로 구현한 클래스
    3) 컨텍스트(Context): 전략을 사용하는 클라이언트

    동작 과정
    1) 컨텍스트는 필요에 따라 전략을 설정
    2) 클라이언트가 요청을 보내면, 컨텍스트는 설정된 전략에 따라 적절한 알고리즘을 실행

    사용 시기
    1) 여러 알고리즘 중 하나를 동적으로 선택하여 사용해야 할 때
    2) 클라이언트가 동일한 문제를 해결하기 위해 여러 알고리즘을 사용할 수 있어야 할 때
    3) 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경하거나 확장해야 할 때

3. **Command(명령)**: **요청**을 객체의 형태로 **캡슐화**하여, 사용자 정의 요청에 따라 저장하거나 전달할 수 있도록 한다.

    사용 예시
    1) 텍스트 편집기에서 **Undo/Redo** 기능을 구현하는 시스템
    2) 리모컨에서 버튼을 누르는 것을 Command 객체로 나타내어 동작을 수행하는 기능

    주요 구성 요소
    1) Command: 요청을 나타내는 인터페이스
    2) ConcreteCommand: 실제 요청을 구현하는 클래스
    3) Invoker: 요청을 실행하는 객체
    4) Receiver: 요청을 처리하는 객체

    동작 과정
    1) 클라이언트가 요청을 생성하고 Command 객체를 생성한다.
    2) Invoker는 Command 객체를 실행하여 요청을 처리한다.
    3) Command 객체는 Receiver에게 요청을 전달하고 실행한다.

    장점
    1) 요청을 캡슐화하여 재사용성을 높임
    2) 실행되는 요청을 객체로 표현하여 조작 및 확장이 용이

    사용 시기
    1) 요청을 객체로 캡슐화하여 다양한 조합으로 조작해야 할 때
    2) 실행되는 요청에 대한 로깅, 취소, 재실행 등의 기능이 필요할 때


4. **State(상태)**: **객체의 내부 상태가 변경**될 때 **객체의 행동도 변경**되도록 한다.

    예시
    1) **주문 상태에 따라 주문을 처리**하는 온라인 쇼핑 시스템
    2) **자판기의 상태에 따라 동작**하는 음료 자판기 시스템

    주요 구성 요소
    1) Context: 상태를 가지고 있는 객체
    2) State: 상태를 나타내는 인터페이스
    3) ConcreteState: 실제 상태를 구현하는 클래스

    동작 과정
    1) Context가 현재 상태를 가지고 있다.
    2) 클라이언트가 Context에 요청을 보낸다.
    3) Context는 현재 상태에 따라 요청을 처리하거나 새로운 상태로 전이한다.

    장점
    1) 상태에 따른 행위를 캡슐화하여 유지보수성을 높인다.
    2) 상태 전이를 명확하게 정의하여 상태 관리를 용이하게 한다.

    사용 시기
    1) 객체의 행동이 상태에 따라 달라지는 경우
    2) 상태 전이가 복잡하고 다양한 경우

5. **Iterator(반복자)**: 컬렉션의 구현 방법을 노출시키지 않고 그 요소들을 **순회**할 수 있는 방법을 제공한다.

    사용 예시
    1) 컬렉션을 순회하는 **반복** 작업을 처리하는 프로그램
    2) 데이터베이스 결과 집합을 처리하는 데이터 접근 계층(DAL)의 구현

    주요 구성 요소
    1) Iterator: 순회할 요소들의 인터페이스를 제공
    2) ConcreteIterator: 실제 요소를 순회하는 클래스
    3) Aggregate: 요소들의 집합을 나타내는 인터페이스
    4) ConcreteAggregate: 실제 요소들의 집합을 구현하는 클래스

    동작 과정
    1) 클라이언트는 Aggregate 객체로부터 Iterator를 얻는다.
    2) Iterator는 Aggregate의 요소들을 순회하면서 접근한다.
    3) 클라이언트는 Iterator를 통해 요소에 접근하고 작업을 수행한다.

    장점
    1) 순회 방법을 캡슐화하여 요소에 독립적으로 접근할 수 있다.
    2) 여러 종류의 Aggregate에 대해 일관된 방식으로 순회할 수 있다.

    사용 시기
    1) 집합 객체를 순회하며 접근할 때
    2) 여러 종류의 집합 객체에 대해 일관된 방식으로 접근해야 할 때

이러한 패턴들은 각각 다양한 문제에 대한 솔루션을 제공하며, **복잡한 시스템 설계**에 있어서 효율성과 유지보수성을 높이는 데 큰 도움을 준다. 디자인 패턴을 이해하고 적절히 활용하는 것은 소프트웨어 개발의 효율성을 크게 높일 수 있다.

## 마무리
싱글톤 패턴은 소프트 웨어 설계에서 반복적으로 발생하는 문제 해결을 위한 디자인 패턴 중 객체 생성과 관련된 대표적인 패턴으로 프로그램에 단 하나만 존재해야하면서 동시에 전역에서 사용 가능한 객체가 필요할 때 사용된다. 비용이 최소화되고 사용하기 쉽다는 장점이 있는 반면, 모듈간 의존성이 높아진다는 문제가 있다. 의존성 문제는 DI로 해결 가능하나, 복잡성이 증가한다는 문제가 있다. 그리고 TDD 수행 시, 독립적인 실행이 불가하다는 단점이 있다. 디자인 패턴은 기존에 개발하면서 생겼었던 문제점들에 대해 오브젝트 관계를 화용해 해결할 방법들을 기록하고 모아놓은 패턴이다. 수업시간에 싱글톤 패턴에서 대해서 배우고 궁금해서 찾아봤는데.. 너무 많고 실제 예시를 살펴봐도 아직은 어디서 어떻게 사용할 수 있는지 감이 잡히지 않았다. 개발자들 사이에는 본인이 만든 것, 겪었던 문제, 코드 등을 항상 공유하는 문화를 가지고 있다고 "오늘부터 개발자(김병욱)"에서 읽은 기억이 있다. 깃허브에 공유되어 있는 방대한 오픈 소스들만 봐도 알 수 있는 문화였다. 김병욱 작가는 그 이유에 대해서 개발자들이 반복하는 것을 싫어해서라고 했다. 그래서 프로그래밍 언어와 툴, 프레임워크, 라이브러리들이 그렇게 다양하고 많은 것일 수 도 있겠다. 계속해서 보완하고 효율적으로 개선하고 새로운 것이들 생겨나고 트렌드는 지나가고. 내가 동경하고 멋있다고 생각하는 문화에 실질적으로 한 발 내디뎠다고 생각하니 조금은 두렵고 지나가버린 영광들의 아쉬움과 서러움이 느껴져 센치해진다. 덜덜 떨면서 등원하던 날이 엊그제 같은데, 이젠 반팔을 입어야 겠다 생각하며 등원한다. 시간은 빠르고 나는 장기전이야, 꾸준한게 중요해 라고 스스로를 다독이지만 마음은 자꾸 조급해진다. 대단한 천재 개발자가 되지 않아도 괜찮아. 어제보다 한걸음 나아가는 걸로 충분해. 또 어느날은 열걸음 가는 날이 있겠지. 끝까지 꾸준하게 화이팅 하자!  