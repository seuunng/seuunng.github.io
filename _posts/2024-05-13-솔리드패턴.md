---
layout: post
title: 
author: 개발자씅
categories: 
- 코딩
tags: 
keywords: 
date: 2024-05-13 10:00 +0800
lastmode: 2024-05-13 10:00 +0800
published: true
toc: true
excerpt: 
description: 
---
개발 방법론, 개발 원칙, 아키텍처 패턴, 디자인 패턴은 다 비슷해서 구분이 어렵지만, 각각의 목적과 적용 범위에서 차이가 있다. 여기서 각 요소가 어떻게 다른지 구분해 보겠다.  

1. 개발 방법론 (Software Development Methodology): 소프트웨어를 개발하는 절차나 규칙, 기법을 체계적으로 정리한 것  
 프로젝트의 시작부터 끝까지 어떻게 관리하고 진행할지의 전반적인 프레임워크를 제공한다.   
 예: 애자일(Agile), 스크럼(Scrum), 린(Lean), 워터폴(Waterfall) 등  

2. 개발 원칙 (Principles of Software Development): 개발 원칙은 좋은 소프트웨어를 만들기 위한 지침이나 규칙   
코드의 품질을 높이고 유지 보수를 용이하게 하기 위해 따르는 일반적인 가이드라인을 제공합니다.   
예: SOLID 원칙, DRY (Don't Repeat Yourself), KISS (Keep It Simple, Stupid) 등  

3. 아키텍처 패턴 (Architectural Pattern): 소프트웨어의 전체 구조를 설계하는 데 사용되는 패턴  
시스템의 구성요소들이 어떻게 상호 작용할지에 대한 고수준의 패턴을 제공하며, 큰 그림에서 시스템을 조직화하는 방법에 대한 지침을 준다.   
예: MVC (Model-View-Controller), 마이크로서비스, 모노리틱 아키텍처 등  

4. 디자인 패턴 (Design Pattern): 보다 구체적인 소프트웨어 설계 문제에 대한 해결책을 제공 
반복적으로 발생하는 문제들을 효과적으로 해결하기 위한 재사용 가능한 솔루션입니다. 디자인 패턴은 아키텍처 패턴보다는 좀 더 상세한 수준에서 개별 컴포넌트 또는 클래스의 설계에 초점을 맞춥니다. 
예: 싱글턴(Singleton), 팩토리(Factory), 옵저버(Observer) 등

****
자바에서 객체지향 설계 원칙은 소프트웨어 개발에서 유지보수가 쉽고, 확장 가능하며, 관리 가능한 코드를 작성하기 위해 따라야 할 몇 가지 기본적인 규칙을 제공한다. 이러한 원칙들은 코드의 재사용성을 높이고, 변경에 대한 유연성을 증가시키며, 결함을 줄이는 데 도움을 줍니다. 오늘은 자바를 포함한 모든 객체지향 프로그래밍 언어에서 권장되는 주요 설계 원칙중 하나인 SOLID 원칙을 살펴보려고 한다.

>객체지향 프로그래밍

## SOLID 원칙
SOLID는 객체 지향 프로그래밍과 디자인에 적용되는 다섯 가지 기본 원칙의 약자로, 소프트웨어의 설계를 더 이해하기 쉽고, 유연하며, 유지보수가 쉬운 방향으로 유도한다.
> S: **Singl**e Responsibility Principle (단일 책임 원칙)  
O: **Open**/Closed Principle (개방-폐쇄 원칙)  
L: **Liskov** Substitution Principle (리스코프 치환 원칙)  
I: **Interface* Segregation Principle (ISP,인터페이스 분리 원칙)  
D: **Dependency** Inversion Principle (의존성 역전 원칙)  

### 단일 책임 원칙
> 하나의 클래스는 한가지 기능이나 한가지 역할만 하도록 설계한다.

한 클래스는 하나의 책임만을 가져야 한다. 클래스가 변경되는 이유는 단 하나여야 한다. 이렇게 설계 해야 어떤 기능에 문제가 있을때 해당 기능을 담당하는 클래스만 수정하면 되기 때문에 다른 기능에 연속적인 문제 발생이나 다른 영향을 차단 할 수 있다. 코드가 간결하고 깔끔하게 정리되어 가독성도 높아진다. 추후 소프트웨어가 성장하고 요구사항이 변화함에 따라 시스템을 보다 쉽게 확장하고 수정할 수 있다.

### 개방/폐쇄 원칙
> 소프트웨어 엔티티는 확장에 대해서 개방적, 수정에 대해서 폐쇄적으로 설계한다.

기존의 코드를 변경하지 않고도 시스템의 기능을 확장할 수 있어야 한다. 새로운 기능을 추가할 수 있기 때문에 시스템의 유지보수성이 향상되고 확장성이 뛰어나 진다. 이를 통해 기존 코드의 재사용성도 증가하고, 변경으로 인한 오류 가능성이 감소한다.
개방/폐쇄 원칙을 구현하기 위해 추상화와 다형성을 활용한다. 인터페이스나 추상 클래스를 사용하여 고정된 부분과 변경되는 부분을 분리함으로써 새로운 기능을 추가할 때 기존 코드에 영향을 주지 않고 확장 할 수 있다.
> **추상화**: 복잡한 문제를 단순화시키는 프로세스로 복잡한 내부 구현 로직은 숨기고 사용자에게는 필요한 기능만 강조하여 표현하는 기술이다. 자동차를 예로 들면, 운전자는 엔진, 변속기 등의 복잡한 메커니즘을 모르더라도 운전대와 페달을 통해 자동차를 운전할 수 있다.  여기서 운전대와 페달은 추상화된 인터페이스 역할을 하고 복잡한 내부 메커니즘은 운전자로 부터 숨겨져 있다. 복잡한 로직에 대하여 생각할 필요없이 인터페이스를 통해 제공되는 메서드를 그냥 사용만 하면 된다.   

> **다형성**: 많은 형태를 가짐을 의미하며, 이는 메서드나 객체가 다양한 방식으로 작동할 수 있는 능력을 의미한다. 다형성은 주로 오버로딩과 오버라이딩 형태로 나타난다. 오버로딩은 같은 이름의 메서드가 다른 매개변수를 가지고 다양한 작업을 수행하여 다형성을 늘리는 형태이고 오버라이딩은 하위 클래스가 상위클래스의 메서드를 재정의하여 동일한 메서드 호출에 대해 다른 행동을 수행하여 다형성을 향상시킨다.

간단한 기능을 제공하는 추상화 된 인터페이스를 정의해서 예를 들어 결제 기능을 수행하는 클래스를 구현한다. 그리고 동일한 인터페이스를 오버라이딩해서 
결제기능 중에서 실행 시점에 결정되는 객체의 타입에 따라 다른 결제 방식이 사용되는 클래스를 구현 할 수 있다. 이렇게 하나의 인터페이스를 수정하지 않고 기능을 확장시켜서 사용할 수 있도록 설계한다.

### 리스코프 치환 원칙
>프로그램에서 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 프로그램의 정확성이 변하지 않아야 한다.

리스코프 치환 원칙은 "서브타입은 언제나 그들의 베이스 타입으로 교체될 수 있어야 한다"는 개념을 의미한다. 프로그램에서 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 수 있어야 한다. 하위 클래스는 기반 클래스의 행동을 제대로 이해하고 확장해야 한다. 이를 통해 코드의 재사용성을 높이고, 클래스 간의 관계를 간소화할 수 있다. 부모 클래스의 메서드를 오버라이딩할때 전제 조건과 후 조건을 변경해서는 안된다.

>인터페이스와 구현클래스가 같은 메서드를 정의하고 있다 하더라도, 인터페이스를 써야 하는 이유?  
계약기반프로그래밍: 인터페이스는 클래스가 따라야 할 명화한 계약을 제공, 코드의 일관성과 안정성을 보장  
다형성: 인터페이스 하나로 다양한 클래스가 생성될 수 있다.  
인터페이스의 역할: 명세정의, 계약설정, 결합도 감소, 다형성 촉진  

부모클래서의 메서드를 재정의할 때 외부에 보이는 행동이 부모 클래스의 메서드와 동일해야 한다. 구현을 공유하는 것 보다는 인터페이스를 공유하도록 한다. 이를 통해 클래스 간 결합도를 낮추고 각 클래스의 독립성을 보장한다.

### 인터페이스 분리 원칙
>클라이언트는 자신이 사용하지 않는 메서드에 의존하도록 강요받아서는 안 된다.

인터페이스 설계를 더 깔끔하고 효율적으로 할 수 있을지에 대한 지침을 제공한다. 클래스가 불필요한 의존성을 갖지 않도록 함으로써, 변경이 필요할 때 최소한의 영향만을 미치게 한다. 이 원칙을 지킴으로써 시스템 구성 요소의 독립성을 증가시킬 수 있다.  
클라이언트가 사용하지 않는 메서드를 포함하는 인터페이스를 강제로 구현하게 되면, 그 인터페이스를 구현하는 클래스는 필요없는 메서드까지 구현해야하므로 코드의 복잡도가 증가한다. 또한, 인터페이스에 변화가 생길 경우, 이를 구현하는 모든 클래스에 영향을 줄 수 있으므로 너무많은 기능을 하나의 인터페이스에 넣는것은 바람직하지 않다.
인터페이스 분리 원칙을 구현하기 위해서는 클라이언트의 요구사항에 맞는 특화된 인트페이스를 제공해야 한다. 그렇게 함으로 각 클라이언트는 자신에게 필요한 메서드만을 포함하는 인터페이스에 의존하게 한다.
크로 포괄적인 인터페이스 대신 작고 구체적인 인터페이스를 여러개로 분리하여 각 인터페이스가 하나의 구체적인 역할 만 수행하도록 한다.
인터페이스 분리 원칙을 구현하면 각 클래스는 자신에게 필요한 인터페이스만을 구현하게 되며, 이는 시스템의 유지보수와 확장을 더욱 쉽게 만든다. 클라이언트가 불필요한 의존성으로부터 자유로워짐으로써, 코드의 안정성도 크게 향상된다.

### 의존성 역전 원칙
> 수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.

 구현체가 아닌 추상화에 의존함으로써, 모듈 간의 결합도를 낮추고 시스템의 유연성을 증가시킨다.
>모듈 :
>구현체 :
>의존성 :

이 원칙들은 객체 지향 설계의 품질을 개선하고, 코드의 재사용성을 높이며, 확장성을 향상시키는 데 기여한다. 디자인을 처음부터 SOLID 원칙에 따라 구성하면 나중에 시스템을 수정하고 유지하기가 훨씬 쉬워진다.

## 마무리


의존성 역전 원칙의 기본 개념
의존성 역전 원칙은 두 가지 주요 내용을 포함합니다:

고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 양쪽 모두 추상화에 의존해야 합니다.
추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다.
이 원칙은 전통적인 의존성 관계를 역전시키는 것을 목표로 합니다. 일반적으로 구현 세부 사항(저수준 모듈)은 추상화(고수준 모듈)에 의존하는 구조인데, DIP는 이를 반대로 뒤집어서 고수준 모듈이 저수준 모듈의 구현 세부 사항에 직접 의존하지 않도록 합니다.

의존성 역전 원칙의 중요성
유연성과 확장성: 고수준 모듈이 저수준 모듈의 구현에 직접적으로 의존하지 않기 때문에, 저수준 모듈을 변경하거나 교체하는 것이 용이해집니다. 이를 통해 시스템의 유연성과 확장성이 크게 향상됩니다.
재사용성: 추상화를 통한 모듈의 결합도 감소는 재사용성을 증가시킵니다. 다양한 컨텍스트에서 같은 추상화를 재사용할 수 있게 됩니다.
테스트 용이성: 고수준 모듈이 저수준 모듈의 구체적인 구현에 의존하지 않으므로, 단위 테스트가 훨씬 용이해집니다. 모의 객체나 스텁을 사용하여 고수준 모듈을 독립적으로 테스트할 수 있습니다.
위 예제에서 Service 클래스는 DataRepository 인터페이스에 의존합니다. 이 구조는 Service가 데이터를 얻는 구체적인 방법(예를 들어, 데이터베이스 접근, 파일 시스템 접근 등)에 의존하지 않기 때문에, DataRepository의 다른 구현으로 쉽게 교체할 수 있습니다. 이는 고수준 모듈과 저수준 모듈 사이의 의존성을 역전시키는 전형적인 예입니다.

객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그래밍의 한 패러다임으로, 소프트웨어를 객체들의 집합으로 모델링하여 설계하고 프로그래밍하는 방식입니다. 이 패러다임은 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 하나의 단위인 객체로 묶어 처리합니다. 객체 지향 프로그래밍의 핵심 목표는 코드의 재사용성, 확장성, 유지보수성을 향상시키는 것입니다.

객체 지향 프로그래밍의 주요 개념
객체 지향 프로그래밍은 몇 가지 핵심 개념에 기반합니다:

클래스와 객체

클래스(Class): 객체를 생성하기 위한 템플릿 또는 블루프린트입니다. 클래스는 객체의 데이터 구조와 메서드를 정의합니다.
객체(Object): 클래스에 기반하여 생성된 인스턴스입니다. 객체는 클래스에 정의된 속성과 메서드를 실제 데이터와 함께 포함합니다.
상속(Inheritance)

상속은 한 클래스(자식 클래스)가 다른 클래스(부모 클래스)의 속성과 메서드를 받아 사용할 수 있게 하는 기능입니다. 이를 통해 코드의 재사용성을 높이고, 중복을 줄일 수 있습니다.
캡슐화(Encapsulation)

캡슐화는 객체의 세부 구현 내용을 숨기고, 외부에서 접근 가능한 인터페이스만을 제공하는 기법입니다. 이를 통해 객체의 데이터를 보호하고, 객체 간의 상호작용을 명확하게 할 수 있습니다.
다형성(Polymorphism)

다형성은 같은 이름의 메서드가 여러 객체에 대해 다른 동작을 수행할 수 있도록 하는 개념입니다. 이는 메서드 오버로딩(같은 이름의 메서드가 다른 매개변수를 가질 수 있음)