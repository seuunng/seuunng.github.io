---
layout: post
title: 비동기식 코드 순서 제어하기
author: 개발자씅
categories: 
- 코딩
tags: 동기식코드 비동기식코드 promise async/await async await 콜백함수 
date: 2024-05-03 10:00 +0800
lastmode: 2024-05-03 10:00 +0800
sitemap:
  changefreq: daily
  priority : 1.0
published: true
toc: true
excerpt: 동기식 코드와 비동기식 코드의 비교, 비동기식 코드 순서 제어하는 이유와 방법.
---

## 동기식 코드
> 순차적. 
한번에 하나씩. 쉬움. 
사용자가 의지를 가지도 전송, 보내기 등 요청 버튼을 누를 때 실행.

**동기식 코드**는 일반적으로 비동기식 코드보다 **간단**하고, 코드가 **순차적**으로 실행되기 때문에 기대한 결과를 얻기 위새서 사용된다. 다음 예제에서 console.log()함수로 숫자를 출력하고자 했고 순서대로 결과가 나왔다. **예상한 결과**를 얻었다.
동기식 코드는 작업이 순차적으로 실행되고 결과가 즉시 반환되는 경우에 적합하다. 그러나, 네트워크 요청이나 파일읽기 같은 I/O작업이 많은 경우, 이러한 작업들이 완료될때 까지 기다리는 동안 다른 작업이 중단되어야 해서 비동기식 코드를 사용하는 것이 더 효율적이다.

```
    console.log(1);
    console.log(2);
    console.log(3);
	
 // 1->2->3 순서대로 실행됨: 동기식
```

## 비동기식 코드
>순서랑 상관없이. 
한번에 여러개 실행. 
정해진틀로만 기능을 수행시키기 어려움. 

비동기식 코드는 주로 네트워크 요청, 파일 시스템 엑세스, 데이터베이스 쿼리 등 시간이 오래 걸리는 **복잡한 작업**을 수행할 때 주로 사용한다. 시간이 오래 걸리는 작업이 진행되는 중에도 다른 작업을 진행할 수 있다. 다음 코드에서 두번째 console.log() 함수의 실행시간을 1초 지연시켰다. 그에 따른 결과가 순차적이지 않게 된다. 이렇게 비동식 코드로 설계할 수 있다.

```
//setTimeOut으로 console(2)실행시간을 지연시켜서 비동기식으로 설계
        console.log(1);
        setTimeout(()=>{console.log(2)}, 1000);
        console.log(3);
```
  
## 비동기식 코드의 순서를 제어해야 하는 이유
복잡한 작업이 진행될 때, 한 가지 작업이 끝날때까지 기다리지 않고 다른 작업이 시작될 수 있는 비동기식으로 진행되도록 하는 것이 일반적이다. 그러나 개발자는 **비동기식 코드의 순서를 제어**할 수 있어야 한다. 

1. **의존성 관리**: 비동기 작업들 간에 의존성이 있을 때, 특정 작업이 완료되기 전에 다른 작업을 실행하면 오류가 발생할 수 있다. 순서를 제어하여 작업 간의 의존성을 관리할 수 있다.
2. **의도한 대로 결과 처리**: 비동기 작업이 완료된 후에만 특정 작업을 수행해야 하는 경우가 있습니다. 예를 들어, 비동기적으로 데이터를 가져온 후에는 그 데이터를 기반으로 뷰를 업데이트해야 할 수 있습니다. 이럴때 순서를 제어해야 **의도한 대로** 작업이 진행되도록 할 수 있다.
3. **오류 처리**: 비동기 작업 중에 오류가 발생한 경우 적절히 처리해야 한다. 특정 작업의 **실패 여부**에 따라 다른 동작을 취할 수 있도록 순서를 제어한다.
4. **가독성과 유지보수성**: 코드가 비동기 작업들이 연속적으로 실행되는지 여부를 명확히 나타내면 코드의 **가독성**과 **유지보수성**이 향상한다. 또한 순서를 제어하여 코드의 **의도를 명확**히 표현할 수 있다.  

비동기식 코드로 인해 발생할 수 있는 문제들을 순서를 제어하여 더 **효율**적으로 작성하고 **유지보수가 수월**한 코딩을 할 수 있다.

## 실행순서를 제어하는 방법

### 콜백함수 활용

비동기식 프로그래밍에서 **콜백함수**는 특정작업이 **완료**될 때 **실행**되는 함수다. 이를 통해 한 작업이 완료된 후에 다른 작업을 실행하거나 **작업의 성공 또는 실패**에 따라 다른 작업을 수행할 수 있다. 이를 통해 **코드의 흐름을 관리**하고 비동기 작업의 **순서를 제어**할 수 있다.

1. **setTimeOut**	: **타이머 걸 수 있는 함수**, 1초 **후**에 실행하겠다. **한 번만** 호출 됨
2. **setInterver** : **타이머 걸 수 있는 함수**, 30초**마다** 실행하겠다. **시간마다** 계속 실행 됨
3. **clearTimeOut** : 타이머 **해제**하는 함수

```
setTimeout(()=>{console.log(2)}, 1000); 
//1초 후에 console.log()를 실행하겠다.
```

### Promise 활용
Promise는 자바스크립트에서 비동기 작업을 처리하기 위한 객체이다. 비동기 작업은 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있게 해준다. 비동기 작업이 **성공 또는 실패하는 시점에 대한 결과를 다루는 객체**이다. Promise는 세 가지 상태를 가진다.

1. **대기**(Pending): 작업이 완료되지 않은 **초기** 상태
2. **이행**(Fulfilled): 작업이 **성공**적으로 완료된 상태
3. **거부**(Rejected): 작업이 **실패**한 상태

Promise를 사용하면 비동기 작업이 완료되었을 때 결과를 처리하거나 오류를 처리할 수 있다. 이를 통해 비동기 코드를 보다 **구조화**하고 **관리하기 쉽게** 만들 수 있다. Promise는 **then()** 메서드를 사용하여 **성공**적인 결과를 처리하고, **catch()** 메서드를 사용하여 **오류**를 처리한다.

```
// 비동기 함수 정의
function addAsync(a, b) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const result = a + b;
            resolve(result);
        }, 1000); // 1초 후에 실행됨
    });
}

// 비동기 함수 호출
console.log("계산 중...");
addAsync(3, 5)
    .then((result) => {
        console.log("결과:", result);
    })
    .catch((error) => {
        console.error("에러 발생:", error);
    });
console.log("이 부분은 먼저 실행됨.");
```

### async/await
**async/await**는 Promise를 기반으로 하며, 코드를 보다 **동기적**으로 작성할 수 있게 해준다. **async** 함수는 항상 **Promise를 반환**하고, **await** 키워드는 Promise가 처리될 때까지 **코드의 실행을 일시 정지**합니다.
async 함수를 사용하면 비동기적인 작업을 수행하고, 이 작업이 완료될 때까지 기다릴 수 있습니다. 

```
<h1>Async/Await Example</h1>
<button id="start-button">Start</button>
<p id="output"></p>

<script>
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// 비동기 함수를 정의
async function asyncTask() {
    const output = document.getElementById("output");

    output.textContent = "Starting async task...";
    await delay(1000); // 1초 대기
    output.textContent = "Task 1 completed.";

    await delay(2000); // 2초 대기
    output.textContent = "Task 2 completed.";

    await delay(1500); // 1.5초 대기
    output.textContent = "All tasks completed!";
}

// 버튼 클릭 이벤트에 비동기 함수 연결
document.getElementById("start-button").addEventListener("click", asyncTask);
</script>
```

## 마무리
이렇게 동기식으로 하면 복잡한 작업을 수행할 수 없기에 비동기식으로 작업을 진행하여 가능성을 열고. 비동기식으로 작업하면 끝나는 순서에 따라 의도하지 않은 결과물이 나올 수 도 있다는 단점을 콜백함수로 보완하였다. 콜백보다는 promise를 사용하여 좀 더 효율적이고 구조화된 코드로 개선하였다. 거기다 async/await를 활용해서 가독성을 높히고 중첩 콜백을 예방했다. 코딩은 간결하고 효율적인 코드로 계속 진화하고 있다. 사실 6개월 만에 여러프로그램잉 언어들 배우는 교육과정에 참여하고 있다 보니, 며칠전에 열심히 공부한 문법에 대해서 그러나 더 간결한 문법이 생겼습니다. 신기해하다 보면, 그러나 그것은 유행이 지났습니다. 오 대박 하다보면. 그러나 지금 실무에선 이런 걸 씁니다. 하는 경우가 많았다. 익숙해질 틈없이 정신없이 배우다 보면. 이렇게 쉬운 게 있었는데 그때 왜 그걸 알려주신거여?🤦‍♂️ 하면서 억울하기도 하지만, 이런 역사적인 흐름과 코딩의 발전과정을 보는 재미가 쏠쏠하기도 하다.(공부하는 입장에서는 재미있지만은 않긴 하다😂) 느닷없이 이런게 코딩의 매력이 아닐까 싶은 생각이 든다.😁 많은 개발자들이 좀 더 효율적이고 좀 더 간결한 코딩을 쓰기 위해 고민하고 있을 것이라는 생각에 괜스레 마음이 웅장해진다. 나도 굿코딩 하는 개발자가 되고 싶다. 화이팅!!😍✌️ 