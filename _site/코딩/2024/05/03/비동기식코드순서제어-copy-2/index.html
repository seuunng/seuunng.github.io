<!doctype html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/pure-min.css" integrity="sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/grids-responsive-min.css">
  <link rel="stylesheet" href="/assets/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <meta name="google-site-verification" content="S3Y0zt33ey8S5mMWq8hgaxqqfGUOfK0LgytcSTbfius" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>비동기식 코드 순서 제어하기 | 결국은 개발자</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="비동기식 코드 순서 제어하기" />
<meta name="author" content="개발자씅" />
<meta property="og:locale" content="ko" />
<meta name="description" content="동기식 코드와 비동기식 코드의 비교, 비동기식 코드 순서 제어하는 이유와 방법." />
<meta property="og:description" content="동기식 코드와 비동기식 코드의 비교, 비동기식 코드 순서 제어하는 이유와 방법." />
<link rel="canonical" href="http://localhost:4000/%EC%BD%94%EB%94%A9/2024/05/03/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D%EC%BD%94%EB%93%9C%EC%88%9C%EC%84%9C%EC%A0%9C%EC%96%B4-copy-2/" />
<meta property="og:url" content="http://localhost:4000/%EC%BD%94%EB%94%A9/2024/05/03/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D%EC%BD%94%EB%93%9C%EC%88%9C%EC%84%9C%EC%A0%9C%EC%96%B4-copy-2/" />
<meta property="og:site_name" content="결국은 개발자" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-05-03T11:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="비동기식 코드 순서 제어하기" />
<meta name="google-site-verification" content="S3Y0zt33ey8S5mMWq8hgaxqqfGUOfK0LgytcSTbfius" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"개발자씅"},"dateModified":"2024-05-13T01:12:33+09:00","datePublished":"2024-05-03T11:00:00+09:00","description":"동기식 코드와 비동기식 코드의 비교, 비동기식 코드 순서 제어하는 이유와 방법.","headline":"비동기식 코드 순서 제어하기","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%EC%BD%94%EB%94%A9/2024/05/03/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D%EC%BD%94%EB%93%9C%EC%88%9C%EC%84%9C%EC%A0%9C%EC%96%B4-copy-2/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/logo.png"},"name":"개발자씅"},"url":"http://localhost:4000/%EC%BD%94%EB%94%A9/2024/05/03/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D%EC%BD%94%EB%93%9C%EC%88%9C%EC%84%9C%EC%A0%9C%EC%96%B4-copy-2/"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="결국은 개발자" />
<link rel="icon" href="/assets/images/favicon.png" type="image/x-icon">
</head>


  <body>

    <div class="container pure-g"><div class="sidebar-left pure-u-1 pure-u-md-1-4" style="background-color: rgb(40, 73, 77); color: rgb(255, 255, 255); background-image: url(/assets/images/bg.jpeg);"><header class="masthead">
  <a href="/about/" title="Profile">
    <div class="avatar"><img src="/assets/images/avatar.jpeg" class="avatar-image" alt="개발자씅">
    </div>
  </a>
  <div class="masthead-title">
    <a href="/" title="Home">결국은 개발자</a>
  </div>
  <div class="masthead-tagline">
    <small>한걸음씩 바지런히 성실하게 차곡차곡</small>
  </div><nav class="navigation">
    <ul class="navigation-list"><li class="navigation-item">
        <a onclick="sessionStorage.setItem('forceCheckScroll', 'true')" href="/">Project</a>
      </li><li class="navigation-item">
        <a onclick="sessionStorage.setItem('forceCheckScroll', 'true')" href="/blog/">Blog</a>
      </li></ul>
  </nav><div class="social pure-menu pure-menu-horizontal">
      <ul class="social-icons pure-menu-list">
      <li class="pure-menu-item">
          <a class="social-icon pure-menu-link" href="https://github.com/seuunng">
            <i class="fab fa-github" title="GitHub"></i>
          </a>
        </li><li class="pure-menu-item">
          <a class="social-icon pure-menu-link" href="https://www.youtube.com/@juumjump">
            <i class="fab fa-youtube" title="Youtube"></i>
          </a>
        </li>
      </ul>
    </div>
</header>
</div>

      <div class="content pure-u-1 pure-u-md-1-2"><main>
  <!-- Post 본문 을 표시 -->
<article class="post">
  <h1 class="post-title">비동기식 코드 순서 제어하기</h1>
  <div class="post-meta"><time datetime="2024-05-03T11:00:00+09:00" itemprop="datePublished">3 May 2024</time><span> ~ </span><time datetime="2024-05-13T01:12:33+09:00" itemprop="dateModified">
        13 May 2024
      </time><span> • </span>
      
        <span itemprop="author" itemscope itemtype="http://schema.org/Person">
          개발자씅
        </span></div>

  <h2 id="동기식-코드">동기식 코드</h2>
<blockquote>
  <p>순차적. 
한번에 하나씩. 쉬움. 
사용자가 의지를 가지도 전송, 보내기 등 요청 버튼을 누를 때 실행.</p>
</blockquote>

<p><strong>동기식 코드</strong>는 일반적으로 비동기식 코드보다 <strong>간단</strong>하고, 코드가 <strong>순차적</strong>으로 실행되기 때문에 기대한 결과를 얻기 위새서 사용된다. 다음 예제에서 console.log()함수로 숫자를 출력하고자 했고 순서대로 결과가 나왔다. <strong>예상한 결과</strong>를 얻었다.
동기식 코드는 작업이 순차적으로 실행되고 결과가 즉시 반환되는 경우에 적합하다. 그러나, 네트워크 요청이나 파일읽기 같은 I/O작업이 많은 경우, 이러한 작업들이 완료될때 까지 기다리는 동안 다른 작업이 중단되어야 해서 비동기식 코드를 사용하는 것이 더 효율적이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    console.log(1);
    console.log(2);
    console.log(3);
	
 // 1-&gt;2-&gt;3 순서대로 실행됨: 동기식
</code></pre></div></div>

<h2 id="비동기식-코드">비동기식 코드</h2>
<blockquote>
  <p>순서랑 상관없이. 
한번에 여러개 실행. 
정해진틀로만 기능을 수행시키기 어려움.</p>
</blockquote>

<p>비동기식 코드는 주로 네트워크 요청, 파일 시스템 엑세스, 데이터베이스 쿼리 등 시간이 오래 걸리는 <strong>복잡한 작업</strong>을 수행할 때 주로 사용한다. 시간이 오래 걸리는 작업이 진행되는 중에도 다른 작업을 진행할 수 있다. 다음 코드에서 두번째 console.log() 함수의 실행시간을 1초 지연시켰다. 그에 따른 결과가 순차적이지 않게 된다. 이렇게 비동식 코드로 설계할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//setTimeOut으로 console(2)실행시간을 지연시켜서 비동기식으로 설계
        console.log(1);
        setTimeout(()=&gt;{console.log(2)}, 1000);
        console.log(3);
</code></pre></div></div>

<h2 id="비동기식-코드의-순서를-제어해야-하는-이유">비동기식 코드의 순서를 제어해야 하는 이유</h2>
<p>복잡한 작업이 진행될 때, 한 가지 작업이 끝날때까지 기다리지 않고 다른 작업이 시작될 수 있는 비동기식으로 진행되도록 하는 것이 일반적이다. 그러나 개발자는 <strong>비동기식 코드의 순서를 제어</strong>할 수 있어야 한다.</p>

<ol>
  <li><strong>의존성 관리</strong>: 비동기 작업들 간에 의존성이 있을 때, 특정 작업이 완료되기 전에 다른 작업을 실행하면 오류가 발생할 수 있다. 순서를 제어하여 작업 간의 의존성을 관리할 수 있다.</li>
  <li><strong>의도한 대로 결과 처리</strong>: 비동기 작업이 완료된 후에만 특정 작업을 수행해야 하는 경우가 있습니다. 예를 들어, 비동기적으로 데이터를 가져온 후에는 그 데이터를 기반으로 뷰를 업데이트해야 할 수 있습니다. 이럴때 순서를 제어해야 <strong>의도한 대로</strong> 작업이 진행되도록 할 수 있다.</li>
  <li><strong>오류 처리</strong>: 비동기 작업 중에 오류가 발생한 경우 적절히 처리해야 한다. 특정 작업의 <strong>실패 여부</strong>에 따라 다른 동작을 취할 수 있도록 순서를 제어한다.</li>
  <li><strong>가독성과 유지보수성</strong>: 코드가 비동기 작업들이 연속적으로 실행되는지 여부를 명확히 나타내면 코드의 <strong>가독성</strong>과 <strong>유지보수성</strong>이 향상한다. 또한 순서를 제어하여 코드의 <strong>의도를 명확</strong>히 표현할 수 있다.</li>
</ol>

<p>비동기식 코드로 인해 발생할 수 있는 문제들을 순서를 제어하여 더 <strong>효율</strong>적으로 작성하고 <strong>유지보수가 수월</strong>한 코딩을 할 수 있다.</p>

<h2 id="실행순서를-제어하는-방법">실행순서를 제어하는 방법</h2>

<h3 id="콜백함수-활용">콜백함수 활용</h3>

<p>비동기식 프로그래밍에서 <strong>콜백함수</strong>는 특정작업이 <strong>완료</strong>될 때 <strong>실행</strong>되는 함수다. 이를 통해 한 작업이 완료된 후에 다른 작업을 실행하거나 <strong>작업의 성공 또는 실패</strong>에 따라 다른 작업을 수행할 수 있다. 이를 통해 <strong>코드의 흐름을 관리</strong>하고 비동기 작업의 <strong>순서를 제어</strong>할 수 있다.</p>

<ol>
  <li><strong>setTimeOut</strong>	: <strong>타이머 걸 수 있는 함수</strong>, 1초 <strong>후</strong>에 실행하겠다. <strong>한 번만</strong> 호출 됨</li>
  <li><strong>setInterver</strong> : <strong>타이머 걸 수 있는 함수</strong>, 30초<strong>마다</strong> 실행하겠다. <strong>시간마다</strong> 계속 실행 됨</li>
  <li><strong>clearTimeOut</strong> : 타이머 <strong>해제</strong>하는 함수</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(()=&gt;{console.log(2)}, 1000); 
//1초 후에 console.log()를 실행하겠다.
</code></pre></div></div>

<h3 id="promise-활용">Promise 활용</h3>
<p>Promise는 자바스크립트에서 비동기 작업을 처리하기 위한 객체이다. 비동기 작업은 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있게 해준다. 비동기 작업이 <strong>성공 또는 실패하는 시점에 대한 결과를 다루는 객체</strong>이다. Promise는 세 가지 상태를 가진다.</p>

<ol>
  <li><strong>대기</strong>(Pending): 작업이 완료되지 않은 <strong>초기</strong> 상태</li>
  <li><strong>이행</strong>(Fulfilled): 작업이 <strong>성공</strong>적으로 완료된 상태</li>
  <li><strong>거부</strong>(Rejected): 작업이 <strong>실패</strong>한 상태</li>
</ol>

<p>Promise를 사용하면 비동기 작업이 완료되었을 때 결과를 처리하거나 오류를 처리할 수 있다. 이를 통해 비동기 코드를 보다 <strong>구조화</strong>하고 <strong>관리하기 쉽게</strong> 만들 수 있다. Promise는 <strong>then()</strong> 메서드를 사용하여 <strong>성공</strong>적인 결과를 처리하고, <strong>catch()</strong> 메서드를 사용하여 <strong>오류</strong>를 처리한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 비동기 함수 정의
function addAsync(a, b) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            const result = a + b;
            resolve(result);
        }, 1000); // 1초 후에 실행됨
    });
}

// 비동기 함수 호출
console.log("계산 중...");
addAsync(3, 5)
    .then((result) =&gt; {
        console.log("결과:", result);
    })
    .catch((error) =&gt; {
        console.error("에러 발생:", error);
    });
console.log("이 부분은 먼저 실행됨.");
</code></pre></div></div>

<h3 id="asyncawait">async/await</h3>
<p><strong>async/await</strong>는 Promise를 기반으로 하며, 코드를 보다 <strong>동기적</strong>으로 작성할 수 있게 해준다. <strong>async</strong> 함수는 항상 <strong>Promise를 반환</strong>하고, <strong>await</strong> 키워드는 Promise가 처리될 때까지 <strong>코드의 실행을 일시 정지</strong>합니다.
async 함수를 사용하면 비동기적인 작업을 수행하고, 이 작업이 완료될 때까지 기다릴 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h1&gt;Async/Await Example&lt;/h1&gt;
&lt;button id="start-button"&gt;Start&lt;/button&gt;
&lt;p id="output"&gt;&lt;/p&gt;

&lt;script&gt;
function delay(ms) {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

// 비동기 함수를 정의
async function asyncTask() {
    const output = document.getElementById("output");

    output.textContent = "Starting async task...";
    await delay(1000); // 1초 대기
    output.textContent = "Task 1 completed.";

    await delay(2000); // 2초 대기
    output.textContent = "Task 2 completed.";

    await delay(1500); // 1.5초 대기
    output.textContent = "All tasks completed!";
}

// 버튼 클릭 이벤트에 비동기 함수 연결
document.getElementById("start-button").addEventListener("click", asyncTask);
&lt;/script&gt;
</code></pre></div></div>

<h2 id="마무리">마무리</h2>
<p>이렇게 동기식으로 하면 복잡한 작업을 수행할 수 없기에 비동기식으로 작업을 진행하여 가능성을 열고. 비동기식으로 작업하면 끝나는 순서에 따라 의도하지 않은 결과물이 나올 수 도 있다는 단점을 콜백함수로 보완하였다. 콜백보다는 promise를 사용하여 좀 더 효율적이고 구조화된 코드로 개선하였다. 거기다 async/await를 활용해서 가독성을 높히고 중첩 콜백을 예방했다. 코딩은 간결하고 효율적인 코드로 계속 진화하고 있다. 사실 6개월 만에 여러프로그램잉 언어들 배우는 교육과정에 참여하고 있다 보니, 며칠전에 열심히 공부한 문법에 대해서 그러나 더 간결한 문법이 생겼습니다. 신기해하다 보면, 그러나 그것은 유행이 지났습니다. 오 대박 하다보면. 그러나 지금 실무에선 이런 걸 씁니다. 하는 경우가 많았다. 익숙해질 틈없이 정신없이 배우다 보면. 이렇게 쉬운 게 있었는데 그때 왜 그걸 알려주신거여?🤦‍♂️ 하면서 억울하기도 하지만, 이런 역사적인 흐름과 코딩의 발전과정을 보는 재미가 쏠쏠하기도 하다.(공부하는 입장에서는 재미있지만은 않긴 하다😂) 느닷없이 이런게 코딩의 매력이 아닐까 싶은 생각이 든다.😁 많은 개발자들이 좀 더 효율적이고 좀 더 간결한 코딩을 쓰기 위해 고민하고 있을 것이라는 생각에 괜스레 마음이 웅장해진다. 나도 굿코딩 하는 개발자가 되고 싶다. 화이팅!!😍✌️</p>





  
</article>


<aside class="related">
  <h2>Related posts</h2>
  <ul class="related-posts">
    
      <li>
        <a href="/%EC%BD%94%EB%94%A9/2024/05/10/vsCode-%EB%8B%A8%EC%B6%95%ED%82%A4/">
          Visual Studio Code 단축키 총집합
          <small><time datetime="2024-05-10T11:00:00+09:00">10 May 2024</time></small>
        </a>
      </li>
      
    
      <li>
        <a href="/%EC%BD%94%EB%94%A9/2024/05/09/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/">
          소프트웨어 설계 문제에 대한 해결책하는 디자인 패턴
          <small><time datetime="2024-05-09T11:00:00+09:00">09 May 2024</time></small>
        </a>
      </li>
      
    
      <li>
        <a href="/%EC%BD%94%EB%94%A9/2024/05/01/access-modifier-JavaKeyword-copy/">
          익숙하지만 낯선 코드, 접근제한자와 Java키워드
          <small><time datetime="2024-05-01T21:00:00+09:00">01 May 2024</time></small>
        </a>
      </li>
      
    
  </ul>
</aside>



</main>

<footer class="footer"><small>
    &copy; 2024 <a href="https://github.com/seuunng/">개발자씅</a>.
    Powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://github.com/vszhub/not-pure-poole">Not Pure Poole</a>.
  </small>
</footer></div>
      <div class="sidebar-right pure-u-1 pure-u-md-1-4">
<div  class="toc-wrapper">
  <h2 class="toc-title">Table of Contents</h2>
    <nav class="toc-nav">
      <ul class="toc">
  <li><a href="#동기식-코드">동기식 코드</a></li>
  <li><a href="#비동기식-코드">비동기식 코드</a></li>
  <li><a href="#비동기식-코드의-순서를-제어해야-하는-이유">비동기식 코드의 순서를 제어해야 하는 이유</a></li>
  <li><a href="#실행순서를-제어하는-방법">실행순서를 제어하는 방법</a>
    <ul>
      <li><a href="#콜백함수-활용">콜백함수 활용</a></li>
      <li><a href="#promise-활용">Promise 활용</a></li>
      <li><a href="#asyncawait">async/await</a></li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a></li>
</ul>

  </nav>
</div>

</div>
    </div>

    <script async src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script><script>
  function strip(str, remove) {
    while (str.length > 0 && remove.indexOf(str.charAt(0)) != -1) {
      str = str.substr(1);
    }
    while (str.length > 0 && remove.indexOf(str.charAt(str.length - 1)) != -1) {
      str = str.substr(0, str.length - 1);
    }
    return str;
  }

  function scroll() {
    console.log('scroll');
    window.scrollTo({
      left: 0, 
      top: window.innerHeight,
      behavior: 'smooth'
    });
    sessionStorage.removeItem('forceCheckScroll');
  }

  const forceCheckScroll = sessionStorage.getItem('forceCheckScroll') === 'true';
  const checkScroll = strip(window.location.pathname, '/') !== strip('/', '/');

  if (forceCheckScroll || checkScroll) {
    const maxWidth = "(max-width: 48rem)";
    const result = window.matchMedia(maxWidth);
    if (result.matches) {
      scroll();
    } else {
      result.addListener((match) => {
        if (match.media == maxWidth) {
          if (match.matches) {
            scroll();
          }
        }
      });
    }
  }
</script>
</body>
</html>

